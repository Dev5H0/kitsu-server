# +FancyLoader+ allows for easily batching complex custom sorts and pagination. It does so through
# heavy use of complex Arel and Postgres window functions, but has performance attributes that make
# it worthwhile.
#
# To use +FancyLoader+, you'll make a subclass to define your sorts and source model. You can then
# create a field which uses your subclass to load data.

class Loaders::FancyLoader < GraphQL::Batch::Loader
  include Loaders::FancyLoader::DSL

  # Get an autogenerated GraphQL type for an order input
  def self.sort_argument
    Loaders::FancyLoader::TypeGenerator.new(self).sorts_list
  end

  # Override the loader key to handle arbitrarily-nested arguments.
  #
  # @todo There *must* be a better way to handle this
  def self.loader_key_for(*group_args, **group_kwargs)
    [group_args, Oj.dump(group_kwargs)]
  end

  # Initialize a FancyLoader. This takes all the keys which are used to batch, which is a *lot* of
  # them. Thanks to the design of GraphQL, however, the frequently-called fields also tend to have
  # the same parameters each time. This means that we can get away with this less-than-ideal
  # batching and still have significant performance gains.
  #
  # @param find_by [Symbol, String] the key to find by
  # @param limit [Integer] The number of rows to retrieve
  # @param offset [Integer] The offset of the rows to retrieve
  # @param sort [Array<{:on, :direction => Symbol}>] The sorts to apply while loading
  # @param token [Doorkeeper::AccessToken] the user's access token
  def initialize(find_by:, limit:, offset: 0, sort:, token:)
    @find_by = find_by
    @limit = limit
    @offset = offset
    @sort = sort.map(&:to_h)
    @token = token
  end

  # Perform the loading. Uses {Loaders::FancyLoader::QueryGenerator} to build a query, then groups
  # the results by the @find_by column, then fulfills all the Promises.
  def perform(keys)
    query = QueryGenerator.new(
      model: model,
      find_by: @find_by,
      limit: @limit,
      offset: @offset,
      sort: sort,
      token: @token,
      keys: keys
    ).query

    results = query.to_a.group_by { |rec| rec[@find_by] }
    keys.each do |key|
      fulfill(key, results[key] || [])
    end
  end

  private

  def sort
    @sort.map do |sort|
      sorts[sort[:on]].merge(direction: sort[:direction])
    end
  end

  def scope
    @scope ||= Pundit::PolicyFinder.new(model).scope!
  end
end
